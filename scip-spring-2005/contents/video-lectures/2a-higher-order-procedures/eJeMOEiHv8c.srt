1
00:00:25,680 --> 00:00:27,960
PROFESSOR: Well, yesterday
was easy.

2
00:00:27,960 --> 00:00:33,020
You learned all of the rules
of programming and lived.

3
00:00:33,020 --> 00:00:34,980
Almost all of them.

4
00:00:34,980 --> 00:00:38,372
And so at this point, you're
now certified programmers--

5
00:00:38,372 --> 00:00:40,200
it says.

6
00:00:40,200 --> 00:00:48,890
However, I suppose what we did
is we, aah, sort of got you a

7
00:00:48,890 --> 00:00:51,700
little bit of into
an easy state.

8
00:00:51,700 --> 00:00:54,770
Here, you still believe it's
possible that this might be

9
00:00:54,770 --> 00:00:59,250
programming in BASIC or Pascal
with just a funny syntax.

10
00:00:59,250 --> 00:01:01,770
Today, that illusion--

11
00:01:01,770 --> 00:01:04,919
or you can no longer support
that belief.

12
00:01:04,919 --> 00:01:06,450
What we're going to do
today is going to

13
00:01:06,450 --> 00:01:08,340
completely smash that.

14
00:01:08,340 --> 00:01:13,590
So let's start out by writing
a few programs on the

15
00:01:13,590 --> 00:01:15,895
blackboard that have a lot in
common with each other.

16
00:01:15,895 --> 00:01:19,540
What we're going to do is try to
make them abstractions that

17
00:01:19,540 --> 00:01:23,880
are not ones that are easy to
make in most languages.

18
00:01:23,880 --> 00:01:26,040
Let's start with some very
simple ones that you can make

19
00:01:26,040 --> 00:01:28,070
in most languages.

20
00:01:28,070 --> 00:01:32,130
Supposing I want to write the
mathematical expression which

21
00:01:32,130 --> 00:01:34,100
adds up a bunch of integers.

22
00:01:34,100 --> 00:01:38,850
So if I wanted to write down
and say the sum from i

23
00:01:38,850 --> 00:01:41,410
equal a to b on i.

24
00:01:41,410 --> 00:01:44,190
Now, you know that that's an
easy thing to compute in a

25
00:01:44,190 --> 00:01:46,180
closed form for it, and I'm
not interested in that.

26
00:01:46,180 --> 00:01:47,140
But I'm going to write
a program that

27
00:01:47,140 --> 00:01:49,045
adds up those integers.

28
00:01:49,045 --> 00:01:57,890
Well, that's rather easy to do
to say I want to define the

29
00:01:57,890 --> 00:02:08,710
sum of the integers from
a to b to be--

30
00:02:08,710 --> 00:02:11,380
well, it's the following
two possibilities.

31
00:02:11,380 --> 00:02:17,430
If a is greater than b, well,
then there's nothing to be

32
00:02:17,430 --> 00:02:19,582
done and the answer is zero.

33
00:02:19,582 --> 00:02:22,530
This is how you're going to
have to think recursively.

34
00:02:22,530 --> 00:02:24,880
You're going to say if I have
an easy case that I know the

35
00:02:24,880 --> 00:02:26,610
answer to, just write it down.

36
00:02:26,610 --> 00:02:29,890
Otherwise, I'm going to try to
reduce this problem to a

37
00:02:29,890 --> 00:02:31,060
simpler problem.

38
00:02:31,060 --> 00:02:33,000
And maybe in this case, I'm
going to make a subproblem of

39
00:02:33,000 --> 00:02:35,340
the simpler problem and then
do something to the result.

40
00:02:35,340 --> 00:02:41,290
So the easiest way to do this
is say that I'm going to add

41
00:02:41,290 --> 00:02:46,530
the index, which in this case is
a, to the result of adding

42
00:02:46,530 --> 00:02:57,960
up the integers from
a plus 1 to b.

43
00:03:02,343 --> 00:03:04,460
Now, at this point, you should
have no trouble looking at

44
00:03:04,460 --> 00:03:06,190
such a definition.

45
00:03:06,190 --> 00:03:09,740
Indeed, coming up with such a
thing might be a little hard

46
00:03:09,740 --> 00:03:12,230
in synthesis, but being able
to read it at this point

47
00:03:12,230 --> 00:03:13,840
should be easy.

48
00:03:13,840 --> 00:03:18,220
And what it says to you is,
well, here is the subproblem

49
00:03:18,220 --> 00:03:19,520
I'm going to solve.

50
00:03:19,520 --> 00:03:24,240
I'm going to try to add up the
integers, one fewer integer

51
00:03:24,240 --> 00:03:26,970
than I added up for the
the whole problem.

52
00:03:26,970 --> 00:03:31,270
I'm adding up the one fewer one,
and that subproblem, once

53
00:03:31,270 --> 00:03:35,150
I've solved it, I'm going to add
a to that, and that will

54
00:03:35,150 --> 00:03:38,550
be the answer to this problem.

55
00:03:38,550 --> 00:03:41,626
And the simplest case, I don't
have to do any work.

56
00:03:41,626 --> 00:03:44,990
Now, I'm also going to write
down another simple one just

57
00:03:44,990 --> 00:03:49,617
like this, which is the
mathematical expression, the

58
00:03:49,617 --> 00:03:55,840
sum of the square from
i equal a to b.

59
00:03:55,840 --> 00:03:58,055
And again, it's a very
simple program.

60
00:04:11,220 --> 00:04:13,510
And indeed, it starts
the same way.

61
00:04:16,029 --> 00:04:21,240
If a is greater than b, then
the answer is zero.

62
00:04:21,240 --> 00:04:24,160
And, of course, we're beginning
to see that there's

63
00:04:24,160 --> 00:04:27,980
something wrong with me writing
this down again.

64
00:04:27,980 --> 00:04:29,820
It's the same program.

65
00:04:29,820 --> 00:04:42,180
It's the sum of the square of a
and the sum of the square of

66
00:04:42,180 --> 00:04:46,134
the increment and b.

67
00:04:50,880 --> 00:04:54,070
Now, if you look at these
things, these programs are

68
00:04:54,070 --> 00:04:56,380
almost identical.

69
00:04:56,380 --> 00:04:59,860
There's not much to
distinguish them.

70
00:04:59,860 --> 00:05:03,140
They have the same first clause
of the conditional and

71
00:05:03,140 --> 00:05:06,250
the same predicate and the
same consequence, and the

72
00:05:06,250 --> 00:05:08,910
alternatives are very
similar, too.

73
00:05:08,910 --> 00:05:15,510
They only differ by the fact
that where here I have a,

74
00:05:15,510 --> 00:05:17,336
here, I have the square of a.

75
00:05:17,336 --> 00:05:22,020
The only other difference, but
this one's sort of unessential

76
00:05:22,020 --> 00:05:25,240
is in the name of this procedure
is sum int, whereas

77
00:05:25,240 --> 00:05:27,560
the name of the procedure
is sum square.

78
00:05:27,560 --> 00:05:29,820
So the things that vary
between these

79
00:05:29,820 --> 00:05:33,250
two are very small.

80
00:05:33,250 --> 00:05:36,080
Now, wherever you see yourself
writing the same thing down

81
00:05:36,080 --> 00:05:38,340
more than once, there's
something wrong, and you

82
00:05:38,340 --> 00:05:40,280
shouldn't be doing it.

83
00:05:40,280 --> 00:05:43,420
And the reason is not because
it's a waste of time to write

84
00:05:43,420 --> 00:05:45,540
something down more than once.

85
00:05:45,540 --> 00:05:50,720
It's because there's some idea
here, a very simple idea,

86
00:05:50,720 --> 00:05:54,620
which has to do with the
sigma notation--

87
00:05:54,620 --> 00:05:57,330
this much--

88
00:05:57,330 --> 00:06:01,255
not depending upon what
it is I'm adding up.

89
00:06:01,255 --> 00:06:03,070
And I would like
to be able to--

90
00:06:03,070 --> 00:06:05,610
always, whenever trying to make
complicated systems and

91
00:06:05,610 --> 00:06:08,575
understand them, it's crucial
to divide the things up into

92
00:06:08,575 --> 00:06:11,030
as many pieces as I can, each
of which I understand

93
00:06:11,030 --> 00:06:13,050
separately.

94
00:06:13,050 --> 00:06:15,030
I would like to understand the
way of adding things up

95
00:06:15,030 --> 00:06:19,540
independently of what it is I'm
adding up so I can do that

96
00:06:19,540 --> 00:06:24,260
having debugged it once and
understood it once and having

97
00:06:24,260 --> 00:06:29,400
been able to share that among
many different uses of it.

98
00:06:29,400 --> 00:06:32,360
Here, we have another example.

99
00:06:32,360 --> 00:06:40,400
This is Leibnitz's formula
for finding pi over 8.

100
00:06:40,400 --> 00:06:43,460
It's a funny, ugly mess.

101
00:06:43,460 --> 00:06:43,930
What is it?

102
00:06:43,930 --> 00:06:50,670
It's something like 1 over 1
times 3 plus 1 over 5 times 7

103
00:06:50,670 --> 00:06:54,340
plus 1 over 9 times 11 plus--

104
00:06:54,340 --> 00:06:59,750
and for some reason, things
like this tend to have

105
00:06:59,750 --> 00:07:02,160
interesting values
like pi over 8.

106
00:07:02,160 --> 00:07:04,460
But what do we see here?

107
00:07:04,460 --> 00:07:07,850
It's the same program or almost
the same program.

108
00:07:07,850 --> 00:07:09,290
It's a sum.

109
00:07:09,290 --> 00:07:12,660
So we're seeing the figure
notation, although over here,

110
00:07:12,660 --> 00:07:17,320
we're dealing with incrementing
by 4, so it's a

111
00:07:17,320 --> 00:07:20,550
slightly different problem,
which means that over here, I

112
00:07:20,550 --> 00:07:25,560
have to change a by 4, as
you see right over here.

113
00:07:25,560 --> 00:07:28,390
It's not by 1.

114
00:07:28,390 --> 00:07:31,150
The other thing, of course,
is that the thing that's

115
00:07:31,150 --> 00:07:34,805
represented by square in the
previous sum of squares, or a

116
00:07:34,805 --> 00:07:36,400
when adding up the integers.

117
00:07:36,400 --> 00:07:38,060
Well, here, I have a different
thing I'm adding up, a

118
00:07:38,060 --> 00:07:44,290
different term, which is 1
over a times a plus 2.

119
00:07:44,290 --> 00:07:45,875
But the rest of this program
is identical.

120
00:07:48,530 --> 00:07:50,640
Well, any time we have a bunch
of things like this that are

121
00:07:50,640 --> 00:07:53,200
identical, we're going to have
to come up with some sort of

122
00:07:53,200 --> 00:07:55,582
abstraction to cover them.

123
00:07:55,582 --> 00:07:59,920
If you think about this, what
you've learned so far is the

124
00:07:59,920 --> 00:08:03,370
rules of some language, some
primitive, some means of

125
00:08:03,370 --> 00:08:06,310
combination, almost all
of them, the means of

126
00:08:06,310 --> 00:08:09,730
abstraction, almost
all of them.

127
00:08:09,730 --> 00:08:13,290
But what you haven't learned is
common patterns of usage.

128
00:08:13,290 --> 00:08:15,150
Now, most of the time, you learn
idioms when learning a

129
00:08:15,150 --> 00:08:18,380
language, which is a common
pattern that mean things that

130
00:08:18,380 --> 00:08:20,760
are useful to know in a flash.

131
00:08:20,760 --> 00:08:22,760
And if you build a great number
of them, if you're a

132
00:08:22,760 --> 00:08:26,180
FORTRAN programmer, of course,
everybody knows how to--

133
00:08:26,180 --> 00:08:29,640
what do you do, for example, to
get an integer which is the

134
00:08:29,640 --> 00:08:31,250
biggest integer in something.

135
00:08:31,250 --> 00:08:32,600
It's a classic thing.

136
00:08:32,600 --> 00:08:34,350
Every FORTRAN programmer
knows how to do that.

137
00:08:34,350 --> 00:08:36,059
And if you don't know that,
you're in real hot water

138
00:08:36,059 --> 00:08:38,150
because it takes a long
time to think it out.

139
00:08:38,150 --> 00:08:41,620
However, one of the things you
can do in this language that

140
00:08:41,620 --> 00:08:43,900
we're showing you is not only
do you know something like

141
00:08:43,900 --> 00:08:48,380
that, but you give the knowledge
of that a name.

142
00:08:48,380 --> 00:08:50,500
And so that's what we're going
to be going after right now.

143
00:08:53,530 --> 00:08:55,860
OK, well, let's see what these
things have in common.

144
00:08:58,680 --> 00:09:02,560
Right over here we have what
appears to be a general

145
00:09:02,560 --> 00:09:06,470
pattern, a general pattern which
covers all of the cases

146
00:09:06,470 --> 00:09:09,700
we've seen so far.

147
00:09:09,700 --> 00:09:15,200
There is a sum procedure,
which is being defined.

148
00:09:15,200 --> 00:09:17,680
It has two arguments, which
are a lower bound

149
00:09:17,680 --> 00:09:19,630
and an upper bound.

150
00:09:19,630 --> 00:09:23,150
The lower bound is tested to
be greater than the upper

151
00:09:23,150 --> 00:09:27,590
bound, and if it is greater,
then the result is zero.

152
00:09:27,590 --> 00:09:31,640
Otherwise, we're going to do
something to the lower bound,

153
00:09:31,640 --> 00:09:35,540
which is the index of the
conversation, and add that

154
00:09:35,540 --> 00:09:40,150
result to the result of
following the procedure

155
00:09:40,150 --> 00:09:45,050
recursively on our lower bound
incremented by some next

156
00:09:45,050 --> 00:09:49,605
operation with the same upper
bound as I had before.

157
00:09:53,710 --> 00:09:59,230
So this is a general pattern,
and what I'd like to do is be

158
00:09:59,230 --> 00:10:03,610
able to name this general
pattern a bit.

159
00:10:03,610 --> 00:10:06,550
Well, that's sort of easy,
because one of the things I'm

160
00:10:06,550 --> 00:10:09,610
going to do right now is--
there's nothing very special

161
00:10:09,610 --> 00:10:11,790
about numbers.

162
00:10:11,790 --> 00:10:14,790
Numbers are just one
kind of data.

163
00:10:14,790 --> 00:10:17,570
It seems to me perfectly
reasonable to give all sorts

164
00:10:17,570 --> 00:10:23,260
of names to all kinds of data,
for example, procedures.

165
00:10:23,260 --> 00:10:26,370
And now many languages allow you
have procedural arguments,

166
00:10:26,370 --> 00:10:27,830
and right now, we're
going to talk

167
00:10:27,830 --> 00:10:29,120
about procedural arguments.

168
00:10:29,120 --> 00:10:31,280
They're very easy
to deal with.

169
00:10:31,280 --> 00:10:33,300
And shortly, we'll do some
remarkable things that are not

170
00:10:33,300 --> 00:10:35,730
like procedural arguments.

171
00:10:35,730 --> 00:10:43,190
So here, we'll define
our sigma notation.

172
00:10:43,190 --> 00:10:55,450
This is called sum and it takes
a term, an A, a next

173
00:10:55,450 --> 00:11:00,190
term, and B as arguments.

174
00:11:00,190 --> 00:11:03,420
So it takes four arguments,
and there was nothing

175
00:11:03,420 --> 00:11:06,580
particularly special about me
writing this in lowercase.

176
00:11:06,580 --> 00:11:08,700
I hope that it doesn't confuse
you, so I'll write it in

177
00:11:08,700 --> 00:11:09,930
uppercase right now.

178
00:11:09,930 --> 00:11:11,180
The machine doesn't care.

179
00:11:14,350 --> 00:11:17,180
But these two arguments
are different.

180
00:11:17,180 --> 00:11:19,360
These are not numbers.

181
00:11:19,360 --> 00:11:21,600
These are going to be procedures
for computing

182
00:11:21,600 --> 00:11:23,690
something given a number.

183
00:11:23,690 --> 00:11:26,590
Term will be a procedure which,
when given an index,

184
00:11:26,590 --> 00:11:29,920
will produce the value of
the term for that index.

185
00:11:29,920 --> 00:11:31,660
Next will be given an
index, which will

186
00:11:31,660 --> 00:11:34,050
produce the next index.

187
00:11:34,050 --> 00:11:36,000
This will be for counting.

188
00:11:36,000 --> 00:11:37,250
And it's very simple.

189
00:11:40,590 --> 00:11:43,400
It's exactly what you see.

190
00:11:43,400 --> 00:11:52,220
If A is greater than B,
then the result is 0.

191
00:11:52,220 --> 00:12:04,970
Otherwise, it's the sum of term
applied to A and the sum

192
00:12:04,970 --> 00:12:10,410
of term, next index.

193
00:12:14,990 --> 00:12:16,480
Let me write it this way.

194
00:12:29,370 --> 00:12:32,160
Now, I'd like you to see
something, first of all.

195
00:12:32,160 --> 00:12:35,210
I was writing here, and
I ran out of space.

196
00:12:35,210 --> 00:12:38,110
What I did is I start indenting
according to the

197
00:12:38,110 --> 00:12:41,080
Pretty-printing rule, which says
that I align all of the

198
00:12:41,080 --> 00:12:44,340
arguments of the procedure
so I can see

199
00:12:44,340 --> 00:12:47,060
which ones go together.

200
00:12:47,060 --> 00:12:49,840
And this is just something I do
automatically, and I want

201
00:12:49,840 --> 00:12:51,530
you to learn how to do that,
too, so your programs can be

202
00:12:51,530 --> 00:12:52,780
read and understood.

203
00:12:54,750 --> 00:12:57,610
However, what do we have here?

204
00:12:57,610 --> 00:13:01,730
We have four arguments: the
procedure, the lower index--

205
00:13:01,730 --> 00:13:03,670
lower bound index--

206
00:13:03,670 --> 00:13:09,010
the way to get the next index,
and the upper bound.

207
00:13:09,010 --> 00:13:13,890
What's passed along on the
recursive call is indeed the

208
00:13:13,890 --> 00:13:18,110
same procedure because I'm going
to need it again, the

209
00:13:18,110 --> 00:13:21,260
next index, which is using the
next procedure to compute it,

210
00:13:21,260 --> 00:13:23,332
the procedure for computing
next, which I also have to

211
00:13:23,332 --> 00:13:25,250
have separately, and
that's different.

212
00:13:25,250 --> 00:13:27,940
The procedure for computing
next is different from the

213
00:13:27,940 --> 00:13:30,680
next index, which is the result
of using next on the

214
00:13:30,680 --> 00:13:32,510
last index.

215
00:13:32,510 --> 00:13:34,210
And I also have to pass
along the upper bound.

216
00:13:37,090 --> 00:13:44,850
So this captures both of these
and the other nice program

217
00:13:44,850 --> 00:13:47,810
that we are playing with.

218
00:13:47,810 --> 00:13:52,740
So using this, we can write down
the original program as

219
00:13:52,740 --> 00:13:56,260
instances of sum very simply.

220
00:14:08,880 --> 00:14:17,620
A and B. Well, I'm going to
need an identity procedure

221
00:14:17,620 --> 00:14:29,440
here because ,ahh, the sum of
the integers requires me to in

222
00:14:29,440 --> 00:14:33,020
this case compute a term for
every integer, but the term

223
00:14:33,020 --> 00:14:35,560
procedure doesn't want to do
anything to that integer.

224
00:14:35,560 --> 00:14:41,460
So the identity procedure on A
is A or X or whatever, and I

225
00:14:41,460 --> 00:14:52,420
want to say the sum of using
identity of the term procedure

226
00:14:52,420 --> 00:14:58,400
and using A as the initial
index and the incrementer

227
00:14:58,400 --> 00:15:05,552
being the way to get the next
index and B being the high

228
00:15:05,552 --> 00:15:07,870
bound, the upper bound.

229
00:15:07,870 --> 00:15:12,010
This procedure does exactly
the same as the sum of the

230
00:15:12,010 --> 00:15:14,140
integers over here, computes
the same answer.

231
00:15:17,690 --> 00:15:21,520
Now, one thing you should see,
of course, is that there's

232
00:15:21,520 --> 00:15:25,220
nothing very special over here
about what I used as the

233
00:15:25,220 --> 00:15:25,990
formal parameter.

234
00:15:25,990 --> 00:15:27,230
I could have, for example,
written this

235
00:15:27,230 --> 00:15:29,690
X. It doesn't matter.

236
00:15:29,690 --> 00:15:33,760
I just wanted you to see that
this name does not conflict

237
00:15:33,760 --> 00:15:35,140
with this one at all.

238
00:15:35,140 --> 00:15:37,850
It's an internal name.

239
00:15:37,850 --> 00:15:40,500
For the second procedure here,
the sum of the squares, it's

240
00:15:40,500 --> 00:15:41,750
even a little bit easier.

241
00:15:53,760 --> 00:15:54,850
And what do we have to do?

242
00:15:54,850 --> 00:16:02,560
Nothing more than add up the
squares, this is the procedure

243
00:16:02,560 --> 00:16:05,620
that each index will be given,
will be given each--

244
00:16:05,620 --> 00:16:06,780
yes.

245
00:16:06,780 --> 00:16:10,410
Each index will have this done
to it to get the term.

246
00:16:10,410 --> 00:16:13,570
That's the thing that maps
against term over here.

247
00:16:13,570 --> 00:16:18,810
Then I have A as the lower
bound, the incrementer as the

248
00:16:18,810 --> 00:16:21,520
next term method, and B
as the upper bound.

249
00:16:26,780 --> 00:16:29,030
And finally, just for the thing
that we did about pi

250
00:16:29,030 --> 00:16:33,270
sums, pi sums are sort of--

251
00:16:33,270 --> 00:16:35,840
well, it's even easier to think
about them this way

252
00:16:35,840 --> 00:16:36,610
because I don't have to think.

253
00:16:36,610 --> 00:16:41,110
What I'm doing is separating the
thing I'm adding up from

254
00:16:41,110 --> 00:16:43,340
the method of doing
the addition.

255
00:16:43,340 --> 00:16:57,200
And so we have here, for
example, pi sum A B

256
00:16:57,200 --> 00:16:59,890
of the sum of things.

257
00:16:59,890 --> 00:17:03,350
I'm going to write the terms
procedure here explicitly

258
00:17:03,350 --> 00:17:05,670
without giving it a name.

259
00:17:05,670 --> 00:17:07,119
This is done anonymously.

260
00:17:07,119 --> 00:17:10,960
I don't necessarily have to give
a name to something if I

261
00:17:10,960 --> 00:17:12,310
just want to use it once.

262
00:17:12,310 --> 00:17:18,050
And, of course, I can write
sort of a expression that

263
00:17:18,050 --> 00:17:19,579
produces a procedure.

264
00:17:19,579 --> 00:17:22,740
I'm going to write the Greek
lambda letter here instead of

265
00:17:22,740 --> 00:17:26,220
L-A-M-B-D-A in general to avoid
taking up a lot of space

266
00:17:26,220 --> 00:17:27,240
on blackboards.

267
00:17:27,240 --> 00:17:28,270
But unfortunately,
we don't have

268
00:17:28,270 --> 00:17:29,960
lambda keys on our keyboards.

269
00:17:29,960 --> 00:17:32,170
Maybe we can convince our
friends in the computer

270
00:17:32,170 --> 00:17:34,040
industry that this
is an important.

271
00:17:34,040 --> 00:17:43,480
Lambda of i is the quotient of 1
and the product of i and the

272
00:17:43,480 --> 00:17:58,020
sum of i 2, starting at a with
the way of incrementing being

273
00:17:58,020 --> 00:18:08,666
that procedure of an index i,
which adds i to 4, and b being

274
00:18:08,666 --> 00:18:09,916
the upper bound.

275
00:18:12,270 --> 00:18:17,490
So you can see that this
notation, the invention of the

276
00:18:17,490 --> 00:18:21,370
procedure that takes a
procedural argument, allows us

277
00:18:21,370 --> 00:18:26,066
to compress a lot of these
procedures into one thing.

278
00:18:26,066 --> 00:18:32,780
This procedure, sums, covers
a whole bunch of ideas.

279
00:18:32,780 --> 00:18:34,740
Now, just why is
this important?

280
00:18:34,740 --> 00:18:37,370
I tried to say before that it
helps us divide a problem into

281
00:18:37,370 --> 00:18:42,760
two pieces, and indeed, it does,
for example, if someone

282
00:18:42,760 --> 00:18:46,570
came up with a different way of
implementing this, which,

283
00:18:46,570 --> 00:18:50,010
of course, one might.

284
00:18:50,010 --> 00:18:51,230
Here, for example, an iterative

285
00:18:51,230 --> 00:18:52,480
implementation of sum.

286
00:18:55,900 --> 00:18:59,470
Iterative implementation for
some reason might be better

287
00:18:59,470 --> 00:19:00,840
than the recursive
implementation.

288
00:19:03,670 --> 00:19:06,460
But the important thing is
that it's different.

289
00:19:06,460 --> 00:19:09,460
Now, supposing I had written my
program this way that you

290
00:19:09,460 --> 00:19:14,310
see on the blackboard
on the left.

291
00:19:14,310 --> 00:19:17,810
That's correct, the left.

292
00:19:17,810 --> 00:19:22,280
Well, then if I want to change
the method of addition, then

293
00:19:22,280 --> 00:19:25,200
I'd have to change
each of these.

294
00:19:25,200 --> 00:19:30,210
Whereas if I write them like
this that you see here, then

295
00:19:30,210 --> 00:19:32,430
the method by which I did the
addition is encapsulated in

296
00:19:32,430 --> 00:19:34,850
the procedure sum.

297
00:19:34,850 --> 00:19:37,780
That decomposition allows me
to independently change one

298
00:19:37,780 --> 00:19:43,210
part of the program and prove
it perhaps without changing

299
00:19:43,210 --> 00:19:45,052
the other part that was
written for some

300
00:19:45,052 --> 00:19:46,630
of the other cases.

301
00:19:50,366 --> 00:19:51,010
Thank you.

302
00:19:51,010 --> 00:19:52,420
Are there any questions?

303
00:19:52,420 --> 00:19:53,190
Yes, sir.

304
00:19:53,190 --> 00:19:55,150
AUDIENCE: Would you go over
next A and next again on--

305
00:19:55,150 --> 00:19:55,640
PROFESSOR: Yes.

306
00:19:55,640 --> 00:19:56,680
It's the same problem.

307
00:19:56,680 --> 00:19:57,900
I'm sure you're going to--

308
00:19:57,900 --> 00:19:59,160
you're going to have
to work on this.

309
00:19:59,160 --> 00:20:01,280
This is hard the first
time you've ever seen

310
00:20:01,280 --> 00:20:02,460
something like this.

311
00:20:02,460 --> 00:20:06,300
What I have here is
a-- procedures

312
00:20:06,300 --> 00:20:07,550
can be named by variables.

313
00:20:10,020 --> 00:20:12,710
Procedures are not special.

314
00:20:12,710 --> 00:20:15,230
Actually, sum square is a
variable, which has gotten a

315
00:20:15,230 --> 00:20:18,640
value, which is a procedure.

316
00:20:18,640 --> 00:20:20,030
This is define sum square to be

317
00:20:20,030 --> 00:20:23,310
lambda of A and B something.

318
00:20:23,310 --> 00:20:24,700
So the procedure can be named.

319
00:20:24,700 --> 00:20:27,900
Therefore, they can be passed
from one to another, one

320
00:20:27,900 --> 00:20:31,430
procedure to another,
as arguments.

321
00:20:31,430 --> 00:20:33,630
Well, what we're doing here is
we're passing the procedure

322
00:20:33,630 --> 00:20:38,190
term as an argument to sum just
when we get it around in

323
00:20:38,190 --> 00:20:41,060
the next recursive.

324
00:20:41,060 --> 00:20:45,350
Here, we're passing
the procedure next

325
00:20:45,350 --> 00:20:47,630
as an argument also.

326
00:20:47,630 --> 00:20:50,120
However, here we're using
the procedure next.

327
00:20:50,120 --> 00:20:51,690
That's what the parentheses
mean.

328
00:20:51,690 --> 00:20:56,750
We're applying next to A to get
the next value of A. If

329
00:20:56,750 --> 00:20:59,390
you look at what next is mapped
against, remember that

330
00:20:59,390 --> 00:21:02,390
the way you think about this
is that you substitute the

331
00:21:02,390 --> 00:21:06,800
arguments for the formal
parameters in the body.

332
00:21:06,800 --> 00:21:10,590
If you're ever confused, think
of the thing that way.

333
00:21:10,590 --> 00:21:14,730
Well, over here, with
sum of the integers.

334
00:21:14,730 --> 00:21:21,150
I substitute identity for
a term and 1 plus the

335
00:21:21,150 --> 00:21:26,070
incrementer for next
in the body.

336
00:21:26,070 --> 00:21:30,600
Well, the identity procedure
on A is what I get here.

337
00:21:30,600 --> 00:21:35,170
Identity is being passed
along, and here, I have

338
00:21:35,170 --> 00:21:41,040
increment 1 plus being applied
to A and 1 plus is being

339
00:21:41,040 --> 00:21:42,980
passed along.

340
00:21:42,980 --> 00:21:46,340
Does that clarify
the situation?

341
00:21:46,340 --> 00:21:49,355
AUDIENCE: We could also define
explicitly those two

342
00:21:49,355 --> 00:21:51,300
functions, then pass them.

343
00:21:51,300 --> 00:21:52,360
PROFESSOR: Sure.

344
00:21:52,360 --> 00:21:54,950
What we can do is we could have
given names to them, just

345
00:21:54,950 --> 00:21:55,770
like I did here.

346
00:21:55,770 --> 00:21:57,530
In fact, I gave you various
ways so you

347
00:21:57,530 --> 00:21:59,390
could see it, a variety.

348
00:21:59,390 --> 00:22:05,130
Here, I define the thing which
I passed the name of.

349
00:22:05,130 --> 00:22:07,850
I referenced it by its name.

350
00:22:07,850 --> 00:22:10,400
But the thing is, in fact, that
procedure, one argument

351
00:22:10,400 --> 00:22:14,300
X, which is X. And the identity
procedure is just

352
00:22:14,300 --> 00:22:20,870
lambda of X X. And that's
what you're seeing here.

353
00:22:20,870 --> 00:22:26,190
Here, I happened to just write
its canonical name there for

354
00:22:26,190 --> 00:22:27,440
you to see.

355
00:22:31,730 --> 00:22:33,020
Is it OK if we take our
five-minute break?

356
00:23:15,850 --> 00:23:19,780
As I said, computers to make
people happy, not people to

357
00:23:19,780 --> 00:23:21,070
make computers happy.

358
00:23:21,070 --> 00:23:23,080
And for the most part, the
reason why we introduce all

359
00:23:23,080 --> 00:23:26,440
this abstraction stuff is to
make it so that programs can

360
00:23:26,440 --> 00:23:29,940
be more easily written
and more easily read.

361
00:23:29,940 --> 00:23:32,930
Let's try to understand what's
the most complicated program

362
00:23:32,930 --> 00:23:36,280
we've seen so far using
a little bit of

363
00:23:36,280 --> 00:23:38,120
this abstraction stuff.

364
00:23:38,120 --> 00:23:44,560
If you look at the slide, this
is the Heron of Alexandria's

365
00:23:44,560 --> 00:23:51,590
method of computing square roots
that we saw yesterday.

366
00:23:51,590 --> 00:23:56,460
And let's see.

367
00:23:56,460 --> 00:24:00,780
Well, in any case, this
program is a little

368
00:24:00,780 --> 00:24:01,805
complicated.

369
00:24:01,805 --> 00:24:04,800
And at the current state of your
thinking, you just can't

370
00:24:04,800 --> 00:24:07,320
look at that and say, oh,
this obviously means

371
00:24:07,320 --> 00:24:10,380
something very clear.

372
00:24:10,380 --> 00:24:12,930
It's not obvious from
looking at the

373
00:24:12,930 --> 00:24:17,060
program what it's computing.

374
00:24:17,060 --> 00:24:21,890
There's some loop here inside
try, and a loop does something

375
00:24:21,890 --> 00:24:26,030
about trying the improvement
of y.

376
00:24:26,030 --> 00:24:30,170
There's something called
improve, which does some

377
00:24:30,170 --> 00:24:33,270
averaging and quotienting
and things like that.

378
00:24:33,270 --> 00:24:34,840
But what's the real idea?

379
00:24:34,840 --> 00:24:38,930
Can we make it clear
what the idea is?

380
00:24:38,930 --> 00:24:41,610
Well, I think we can.

381
00:24:41,610 --> 00:24:45,070
I think we can use abstraction
that we have learned about so

382
00:24:45,070 --> 00:24:48,990
far to clarify what's
going on.

383
00:24:48,990 --> 00:24:54,720
Now, what we have mathematically
is a procedure

384
00:24:54,720 --> 00:24:58,411
for improving a guess
for square roots.

385
00:24:58,411 --> 00:25:02,610
And if y is a guess for a square
root, then what we want

386
00:25:02,610 --> 00:25:04,570
to get we'll call
a function f.

387
00:25:04,570 --> 00:25:07,660
This is the means
of improvement.

388
00:25:07,660 --> 00:25:17,510
I want to get y plus x/y over
2, so the average of y and x

389
00:25:17,510 --> 00:25:24,080
divided by y as the improved
value for the square root of x

390
00:25:24,080 --> 00:25:27,920
such that-- one thing you can
notice about this function f

391
00:25:27,920 --> 00:25:36,310
is that f of the square root
of f is in fact the

392
00:25:36,310 --> 00:25:38,460
square root of x.

393
00:25:38,460 --> 00:25:41,670
In other words, if I take
the square root of x and

394
00:25:41,670 --> 00:25:44,930
substitute it for y here, I see
the square root of x plus

395
00:25:44,930 --> 00:25:47,560
x divided by the square of x,
which is the square root of x.

396
00:25:47,560 --> 00:25:49,890
That's 2 times the square root
of x divided by 2, is the

397
00:25:49,890 --> 00:25:51,640
square root of x.

398
00:25:51,640 --> 00:25:55,630
So, in fact, what we're really
looking for is we're looking

399
00:25:55,630 --> 00:26:12,850
for a fixed point, a fixed
point of the function f.

400
00:26:17,570 --> 00:26:22,650
A fixed point is a place which
has the property that if you

401
00:26:22,650 --> 00:26:24,850
put it into the function, you
get the same value out.

402
00:26:27,620 --> 00:26:29,700
Now, I suppose if I were giving
some nice, boring

403
00:26:29,700 --> 00:26:34,480
lecture, and you happened to
have in front of you an HP-35

404
00:26:34,480 --> 00:26:36,380
desk calculator like I
used to have when I

405
00:26:36,380 --> 00:26:38,170
went to boring lectures.

406
00:26:38,170 --> 00:26:41,120
And if you think it was really
boring, you put it into

407
00:26:41,120 --> 00:26:44,720
radians mode, and you hit
cosine, and you hit cosine,

408
00:26:44,720 --> 00:26:45,780
and you hit cosine.

409
00:26:45,780 --> 00:26:48,770
And eventually, you end
up with 0.734 or

410
00:26:48,770 --> 00:26:50,090
something like that.

411
00:26:50,090 --> 00:26:53,250
0.743, I don't remember what
exactly, and it gets closer

412
00:26:53,250 --> 00:26:54,810
and closer to that.

413
00:26:54,810 --> 00:26:57,980
Some functions have the property
that you can find

414
00:26:57,980 --> 00:27:03,420
their fixed point by iterating
the function, and that's

415
00:27:03,420 --> 00:27:07,170
essentially what's happening in
the square root program by

416
00:27:07,170 --> 00:27:08,420
Heron's method.

417
00:27:11,550 --> 00:27:14,732
So let's see if we can write
that down, that idea.

418
00:27:14,732 --> 00:27:17,670
Now, I'm not going to say how
I compute fixed points yet.

419
00:27:17,670 --> 00:27:19,240
There might be more
than one way.

420
00:27:19,240 --> 00:27:22,750
But the first thing to
do is I'm going to

421
00:27:22,750 --> 00:27:24,310
say what I just said.

422
00:27:24,310 --> 00:27:27,460
I'm going to say it
specifically, the square root.

423
00:27:32,440 --> 00:27:48,210
The square root of x is the
fixed point of that procedure

424
00:27:48,210 --> 00:27:59,180
which takes an argument
y and averages of x

425
00:27:59,180 --> 00:28:02,330
divided by y with y.

426
00:28:05,620 --> 00:28:08,120
And we're going to start up with
the initial guess for the

427
00:28:08,120 --> 00:28:09,630
fixed point of 1.

428
00:28:09,630 --> 00:28:11,860
It doesn't matter
where it starts.

429
00:28:11,860 --> 00:28:13,940
A theorem having to do
with square roots.

430
00:28:18,610 --> 00:28:21,410
So what you're seeing here is
I'm just trying to write out

431
00:28:21,410 --> 00:28:22,560
by wishful thinking.

432
00:28:22,560 --> 00:28:24,380
I don't know how I'm going to
make fixed point happen.

433
00:28:24,380 --> 00:28:26,290
We'll worry about that later.

434
00:28:26,290 --> 00:28:29,570
But if somehow I had a way of
finding the fixed point of the

435
00:28:29,570 --> 00:28:33,590
function computed by this
procedure, then I would have--

436
00:28:33,590 --> 00:28:36,120
that would be the square root
that I'm looking for.

437
00:28:39,770 --> 00:28:41,500
OK, well, now let's see how
we're going to write--

438
00:28:41,500 --> 00:28:43,470
how we're going to come
up with fixed points.

439
00:28:43,470 --> 00:28:44,890
Well, it's very simple,
actually.

440
00:28:44,890 --> 00:28:47,180
I'm going to write an
abbreviated version here just

441
00:28:47,180 --> 00:28:48,430
so we understand it.

442
00:29:00,450 --> 00:29:03,310
I'm going to find the fixed
point of a function f--

443
00:29:03,310 --> 00:29:06,140
actually, the fixed point of the
function computed by the

444
00:29:06,140 --> 00:29:09,990
procedure whose name will
be f in this procedure.

445
00:29:09,990 --> 00:29:11,025
How's that?

446
00:29:11,025 --> 00:29:13,230
A long sentence--

447
00:29:13,230 --> 00:29:14,820
starting with a particular
starting value.

448
00:29:19,920 --> 00:29:22,660
Well, I'm going to have a little
loop inside here, which

449
00:29:22,660 --> 00:29:25,800
is going to push the button on
the calculator repeatedly,

450
00:29:25,800 --> 00:29:28,940
hoping that it will eventually
converge.

451
00:29:28,940 --> 00:29:35,290
And we will say here internal
loops are written by defining

452
00:29:35,290 --> 00:29:36,540
internal procedures.

453
00:29:39,340 --> 00:29:41,860
Well, one thing I'm going to
have to do is I'm going to

454
00:29:41,860 --> 00:29:43,690
have to say whether I'm done.

455
00:29:43,690 --> 00:29:45,410
And the way I'm going to decide
when I'm done is when

456
00:29:45,410 --> 00:29:47,760
the old value and the new value
are close enough so I

457
00:29:47,760 --> 00:29:50,820
can't distinguish
them anymore.

458
00:29:50,820 --> 00:29:53,510
That's the standard thing you
do on the calculator unless

459
00:29:53,510 --> 00:29:54,970
you look at more precision,
and eventually,

460
00:29:54,970 --> 00:29:57,820
you run out of precision.

461
00:29:57,820 --> 00:30:06,530
So the old value and new value,
and I'm going to stay

462
00:30:06,530 --> 00:30:14,758
here if I can't distinguish them
if they're close enough,

463
00:30:14,758 --> 00:30:16,830
and we'll have to worry about
what that is soon.

464
00:30:20,780 --> 00:30:22,580
The old value and the new value
are close enough to each

465
00:30:22,580 --> 00:30:25,880
other and let's pick the new
value as the answer.

466
00:30:25,880 --> 00:30:33,520
Otherwise, I'm going to iterate
around again with the

467
00:30:33,520 --> 00:30:39,020
next value of old being the
current value of new and the

468
00:30:39,020 --> 00:30:43,160
next value of new being the
result of calling f on new.

469
00:30:54,810 --> 00:30:57,680
And so this is my iteration loop
that pushes the button on

470
00:30:57,680 --> 00:30:58,600
the calculator.

471
00:30:58,600 --> 00:31:00,760
I basically think of it as
having two registers on the

472
00:31:00,760 --> 00:31:02,495
calculator: old and new.

473
00:31:02,495 --> 00:31:09,070
And in each step, new becomes
old, and new gets F of new.

474
00:31:09,070 --> 00:31:13,080
So this is the thing where I'm
getting the next value.

475
00:31:13,080 --> 00:31:20,970
And now, I'm going to
start this thing up

476
00:31:20,970 --> 00:31:22,220
by giving two values.

477
00:31:28,470 --> 00:31:30,570
I wrote down on the blackboard
to be slow

478
00:31:30,570 --> 00:31:31,640
so you can see this.

479
00:31:31,640 --> 00:31:34,650
This is the first time you've
seen something quite this

480
00:31:34,650 --> 00:31:37,700
complicated, I think.

481
00:31:37,700 --> 00:31:44,710
However, we might want to see
the whole thing over here in

482
00:31:44,710 --> 00:31:50,720
this transparency or
slide or whatever.

483
00:31:50,720 --> 00:31:57,200
What we have is all of the
details that are required to

484
00:31:57,200 --> 00:31:58,500
make this thing work.

485
00:31:58,500 --> 00:32:01,660
I have a way of getting a
tolerance for a close enough

486
00:32:01,660 --> 00:32:03,080
procedure, which we see here.

487
00:32:03,080 --> 00:32:06,030
The close enough procedure, it
tests whether u and v are

488
00:32:06,030 --> 00:32:09,170
close enough by seeing if the
absolute value of the

489
00:32:09,170 --> 00:32:12,460
difference in u and v is less
than the given tolerance, OK?

490
00:32:12,460 --> 00:32:14,440
And here is the iteration loop
that I just wrote on the

491
00:32:14,440 --> 00:32:17,930
blackboard and the
initialization for it, which

492
00:32:17,930 --> 00:32:19,180
is right there.

493
00:32:21,680 --> 00:32:22,930
It's very simple.

494
00:32:34,210 --> 00:32:34,880
But let's see.

495
00:32:34,880 --> 00:32:36,630
I haven't told you enough.

496
00:32:36,630 --> 00:32:39,500
It's actually easier
than this.

497
00:32:39,500 --> 00:32:42,120
There is more structure to
this problem than I've

498
00:32:42,120 --> 00:32:43,310
already told you.

499
00:32:43,310 --> 00:32:45,700
Like why should this work?

500
00:32:45,700 --> 00:32:48,070
Why should it converge?

501
00:32:48,070 --> 00:32:50,930
There's a hairy theorem in
mathematics tied up in what

502
00:32:50,930 --> 00:32:52,760
I've written here.

503
00:32:52,760 --> 00:32:55,890
Why is it that I should assume
that by iterating averaging

504
00:32:55,890 --> 00:32:57,780
the quotient of x and y
and y that I should

505
00:32:57,780 --> 00:33:00,110
get the right answer?

506
00:33:00,110 --> 00:33:01,360
It isn't so obvious.

507
00:33:03,710 --> 00:33:07,280
Surely there are other things,
other procedures, which

508
00:33:07,280 --> 00:33:09,870
compute functions whose fixed
points would also be the

509
00:33:09,870 --> 00:33:12,040
square root.

510
00:33:12,040 --> 00:33:20,480
For example, the obvious one
will be a new function g,

511
00:33:20,480 --> 00:33:25,330
which maps y to x/y.

512
00:33:27,950 --> 00:33:30,870
That's even simpler.

513
00:33:30,870 --> 00:33:34,540
The fixed point of g is surely
the square root also, and it's

514
00:33:34,540 --> 00:33:37,400
a simpler procedure.

515
00:33:37,400 --> 00:33:39,020
Why am I not using it?

516
00:33:39,020 --> 00:33:40,470
Well, I suppose you know.

517
00:33:40,470 --> 00:33:44,970
Supposing x is 2 and I start out
with 1, and if I divide 1

518
00:33:44,970 --> 00:33:47,700
into 2, I get 2.

519
00:33:47,700 --> 00:33:49,610
And then if I divide
2 into 2, I get 1.

520
00:33:49,610 --> 00:33:52,740
If I divide 1 into 2, I get 2,
and 2 into 2, I get 1, and I

521
00:33:52,740 --> 00:33:55,480
never get any closer
to the square root.

522
00:33:55,480 --> 00:33:56,730
It just oscillates.

523
00:33:59,080 --> 00:34:03,110
So what we have is a signal
processing system, an

524
00:34:03,110 --> 00:34:06,230
electrical circuit which is
oscillating, and I want to

525
00:34:06,230 --> 00:34:07,480
damp out these oscillations.

526
00:34:10,530 --> 00:34:11,840
Well, I can do that.

527
00:34:11,840 --> 00:34:14,190
See, what I'm really doing
here when I'm taking my

528
00:34:14,190 --> 00:34:17,290
average, the average is
averaging the last two values

529
00:34:17,290 --> 00:34:21,350
of something which oscillates,
getting something in between.

530
00:34:21,350 --> 00:34:24,480
The classic way is damping out
oscillations in a signal

531
00:34:24,480 --> 00:34:25,730
processing system.

532
00:34:28,460 --> 00:34:31,719
So why don't we write down the
strategy that I just said in a

533
00:34:31,719 --> 00:34:33,872
more clear way?

534
00:34:33,872 --> 00:34:35,520
Well, that's easy enough.

535
00:34:38,639 --> 00:34:53,790
I'm going to define the square
root of x to be a fixed point

536
00:34:53,790 --> 00:34:58,510
of the procedure resulting
from average damping.

537
00:34:58,510 --> 00:35:10,780
So I have a procedure resulting
from average damp of

538
00:35:10,780 --> 00:35:24,820
the procedure, that procedure
of y, which divides x by y

539
00:35:24,820 --> 00:35:26,070
starting out at 1.

540
00:35:29,840 --> 00:35:33,520
Ah, but average damp is a
special procedure that's going

541
00:35:33,520 --> 00:35:35,720
to take a procedure as its
argument and return a

542
00:35:35,720 --> 00:35:38,080
procedure as its value.

543
00:35:38,080 --> 00:35:42,090
It's a generalization that says
given a procedure, it's

544
00:35:42,090 --> 00:35:45,090
the thing which produces a
procedure which averages the

545
00:35:45,090 --> 00:35:47,980
last value and the
value before and

546
00:35:47,980 --> 00:35:51,320
after running the procedure.

547
00:35:51,320 --> 00:35:53,260
You can use it for anything
if you want to damp out

548
00:35:53,260 --> 00:35:54,880
oscillations.

549
00:35:54,880 --> 00:35:56,495
So let's write that down.

550
00:35:56,495 --> 00:35:57,745
It's very easy.

551
00:36:00,624 --> 00:36:04,590
And stylistically here, I'm
going to use lambda notation

552
00:36:04,590 --> 00:36:06,950
because it's much easier to
think when you're dealing with

553
00:36:06,950 --> 00:36:08,845
procedure, the mid-line
procedures, to understand that

554
00:36:08,845 --> 00:36:11,552
the procedures are the objects
I'm dealing with, so I'm going

555
00:36:11,552 --> 00:36:13,830
to use lambda notation here.

556
00:36:13,830 --> 00:36:14,490
Not always.

557
00:36:14,490 --> 00:36:18,110
I don't always use it, but
very specifically here to

558
00:36:18,110 --> 00:36:22,040
expand on that idea,
to elucidate it.

559
00:36:28,590 --> 00:36:33,810
Well, average damp is a
procedure, which takes a

560
00:36:33,810 --> 00:36:37,560
procedure as its argument,
which we will call f.

561
00:36:37,560 --> 00:36:38,710
And what does it produce?

562
00:36:38,710 --> 00:36:40,340
It produces as its value--

563
00:36:40,340 --> 00:36:43,890
the body of this procedure is
a thing which produces a

564
00:36:43,890 --> 00:36:47,260
procedure, the construct of the
procedures right here, of

565
00:36:47,260 --> 00:37:00,440
one argument x, which averages
f of x with x.

566
00:37:10,420 --> 00:37:14,070
This is a very special thing.

567
00:37:14,070 --> 00:37:17,730
I think for the first time
you're seeing a procedure

568
00:37:17,730 --> 00:37:21,730
which produces a procedure
as its value.

569
00:37:21,730 --> 00:37:25,690
This procedure takes the
procedure f and does something

570
00:37:25,690 --> 00:37:29,360
to it to produce a new procedure
of one argument x,

571
00:37:29,360 --> 00:37:31,050
which averages f--

572
00:37:31,050 --> 00:37:31,950
this f--

573
00:37:31,950 --> 00:37:36,040
applied to x and x itself.

574
00:37:36,040 --> 00:37:40,280
Using the context here, I apply
average damping to the

575
00:37:40,280 --> 00:37:44,670
procedure, which just
divides x by y.

576
00:37:44,670 --> 00:37:45,920
It's a division.

577
00:37:48,122 --> 00:37:51,980
And I'm finding to fixed point
of that, and that's a clearer

578
00:37:51,980 --> 00:37:54,460
way of writing down what
I wrote down over

579
00:37:54,460 --> 00:37:57,796
here, wherever it was.

580
00:37:57,796 --> 00:38:01,110
Here, because it tells why
I am writing this down.

581
00:38:07,910 --> 00:38:11,110
I suppose this to some extent
really clarifies what Heron of

582
00:38:11,110 --> 00:38:14,260
Alexandria was up to.

583
00:38:14,260 --> 00:38:15,130
I suppose I'll stop now.

584
00:38:15,130 --> 00:38:16,380
Are there any questions?

585
00:38:18,190 --> 00:38:21,282
AUDIENCE: So when you define
average damp, don't you need

586
00:38:21,282 --> 00:38:25,210
to have a variable on f?

587
00:38:25,210 --> 00:38:28,150
PROFESSOR: Ah, the question was,
and here we're having--

588
00:38:28,150 --> 00:38:29,900
again, you've got to learn
about the syntax.

589
00:38:29,900 --> 00:38:33,840
The question was when defining
average damp, don't you have

590
00:38:33,840 --> 00:38:38,070
to have a variable
defined with f?

591
00:38:38,070 --> 00:38:40,310
What you are asking about is
the formal parameter of f?

592
00:38:40,310 --> 00:38:41,290
AUDIENCE: Yeah.

593
00:38:41,290 --> 00:38:42,810
PROFESSOR: OK.

594
00:38:42,810 --> 00:38:45,580
The formal parameter
of f is here.

595
00:38:45,580 --> 00:38:47,318
The formal parameter of f--

596
00:38:47,318 --> 00:38:50,190
AUDIENCE: The formal parameter
of average damp.

597
00:38:50,190 --> 00:38:51,890
PROFESSOR: F is being
used to apply it to

598
00:38:51,890 --> 00:38:54,400
an argument, right?

599
00:38:54,400 --> 00:38:57,780
It's indeed true that f must
have a formal parameter.

600
00:38:57,780 --> 00:39:00,380
Let's find out what f's
formal parameter is.

601
00:39:00,380 --> 00:39:02,440
AUDIENCE: The formal parameter
of average damp.

602
00:39:02,440 --> 00:39:04,700
PROFESSOR: Oh, f is the formal
parameter of average damp.

603
00:39:04,700 --> 00:39:05,500
I'm sorry.

604
00:39:05,500 --> 00:39:07,910
You're just confusing
a syntactic thing.

605
00:39:07,910 --> 00:39:10,470
I could have written
this the other way.

606
00:39:10,470 --> 00:39:12,520
Actually, I didn't understand
your question.

607
00:39:12,520 --> 00:39:13,910
Of course, I could have written
it this other way.

608
00:39:19,340 --> 00:39:21,540
Those are identical notations.

609
00:39:21,540 --> 00:39:25,607
This is a different way
of writing this.

610
00:39:31,710 --> 00:39:33,280
You're going to have to get
used to lambda notation

611
00:39:33,280 --> 00:39:35,520
because I'm going to use it.

612
00:39:35,520 --> 00:39:40,460
What it says here, I'm defining
the name average damp

613
00:39:40,460 --> 00:39:44,600
to name the procedure whose
of one argument f.

614
00:39:44,600 --> 00:39:49,250
That's the formal parameter of
the procedure average damp.

615
00:39:49,250 --> 00:39:56,550
What define does is it says
give this name a value.

616
00:39:56,550 --> 00:39:57,860
Here is the value of for it.

617
00:40:01,310 --> 00:40:05,100
That there happens to be a
funny syntax to make that

618
00:40:05,100 --> 00:40:08,085
easier in some cases is
purely convenience.

619
00:40:10,900 --> 00:40:14,540
But the reason why I wrote it
this way here is to emphasize

620
00:40:14,540 --> 00:40:16,530
that I'm dealing with a
procedure that takes a

621
00:40:16,530 --> 00:40:18,100
procedure as its argument
and produces a

622
00:40:18,100 --> 00:40:19,350
procedure as its value.

623
00:40:23,640 --> 00:40:25,800
AUDIENCE: I don't understand
why you use lambda twice.

624
00:40:25,800 --> 00:40:27,760
Can you just use one
lambda and take two

625
00:40:27,760 --> 00:40:29,230
arguments f and x?

626
00:40:29,230 --> 00:40:29,520
PROFESSOR: No.

627
00:40:29,520 --> 00:40:30,330
AUDIENCE: You can't?

628
00:40:30,330 --> 00:40:32,500
PROFESSOR: No, that would
be a different thing.

629
00:40:32,500 --> 00:40:36,190
If I were to write the procedure
lambda of f and x,

630
00:40:36,190 --> 00:40:40,090
the average of f of x and x,
that would not be something

631
00:40:40,090 --> 00:40:42,810
which would be allowed to take a
procedure as an argument and

632
00:40:42,810 --> 00:40:44,580
produce a procedure
as its value.

633
00:40:44,580 --> 00:40:46,330
That would be a thing that
takes a procedure as its

634
00:40:46,330 --> 00:40:48,700
argument and numbers
its argument and

635
00:40:48,700 --> 00:40:50,620
produces a new number.

636
00:40:50,620 --> 00:40:53,650
But what I'm producing here is
a procedure to fit in the

637
00:40:53,650 --> 00:40:56,090
procedure slot over here,
which is going to

638
00:40:56,090 --> 00:40:58,860
be used over here.

639
00:40:58,860 --> 00:41:01,450
So the number has to
come from here.

640
00:41:01,450 --> 00:41:04,440
This is the thing that's going
to eventually end up in the x.

641
00:41:04,440 --> 00:41:07,810
And if you're confused, you
should do some substitution

642
00:41:07,810 --> 00:41:09,060
and see for yourself.

643
00:41:12,010 --> 00:41:12,746
Yes?

644
00:41:12,746 --> 00:41:15,870
AUDIENCE: Will you please show
the definition for average

645
00:41:15,870 --> 00:41:19,320
damp without using lambda
notation in both cases.

646
00:41:19,320 --> 00:41:21,490
PROFESSOR: I can't make a very
simple one like that.

647
00:41:21,490 --> 00:41:22,990
Let me do it for you, though.

648
00:41:22,990 --> 00:41:26,530
I can get rid of this
lambda easily.

649
00:41:26,530 --> 00:41:27,780
I don't want to be--

650
00:41:32,760 --> 00:41:33,810
actually, I'm lying to you.

651
00:41:33,810 --> 00:41:37,170
I don't want to do what you want
because I think it's more

652
00:41:37,170 --> 00:41:39,310
confusing than you think.

653
00:41:39,310 --> 00:41:40,560
I'm not going to write
what you want.

654
00:41:55,450 --> 00:41:56,500
So we'll have to get a name.

655
00:41:56,500 --> 00:42:13,370
FOO of x to be of F of x and x
and return as a value FOO.

656
00:42:17,140 --> 00:42:20,406
This is equivalent, but
I've had to make an

657
00:42:20,406 --> 00:42:21,700
arbitrary name up.

658
00:42:21,700 --> 00:42:26,290
This is equivalent to this
without any lambdas.

659
00:42:26,290 --> 00:42:31,240
Lambda is very convenient for
naming anonymous procedures.

660
00:42:31,240 --> 00:42:34,080
It's the anonymous name
of something.

661
00:42:34,080 --> 00:42:39,780
Now, if you really want to know
a cute way of doing this,

662
00:42:39,780 --> 00:42:41,820
we'll talk about it later.

663
00:42:41,820 --> 00:42:44,680
We're going to have to define
the anonymous procedure.

664
00:42:44,680 --> 00:42:45,930
Any other questions?

665
00:42:49,116 --> 00:42:50,880
And so we go for our
break again.

666
00:43:31,740 --> 00:43:35,380
So now we've seen how
to use high-order

667
00:43:35,380 --> 00:43:36,490
procedures, they're called.

668
00:43:36,490 --> 00:43:38,570
That's procedures that take
procedural arguments and

669
00:43:38,570 --> 00:43:43,310
produce procedural values to
help us clarify and abstract

670
00:43:43,310 --> 00:43:46,470
some otherwise complicated
processes.

671
00:43:46,470 --> 00:43:48,500
I suppose what I'd like to do
now is have a bit of fun with

672
00:43:48,500 --> 00:43:54,080
that and sort of a little
practice as well.

673
00:43:54,080 --> 00:43:56,290
So let's play with this square
root thing even more.

674
00:43:56,290 --> 00:43:59,800
Let's elaborate it and
understand what's going on and

675
00:43:59,800 --> 00:44:04,270
make use of this kind of
programming style.

676
00:44:04,270 --> 00:44:08,680
One thing that you might know
is that there is a general

677
00:44:08,680 --> 00:44:12,990
method called Newton's method
the purpose of which is to

678
00:44:12,990 --> 00:44:15,180
find the roots--

679
00:44:15,180 --> 00:44:17,280
that's the zeroes--

680
00:44:17,280 --> 00:44:19,130
of functions.

681
00:44:19,130 --> 00:44:38,420
So, for example, to find a y
such that f of y equals 0, we

682
00:44:38,420 --> 00:44:40,280
start with some guess.

683
00:44:40,280 --> 00:44:41,530
This is Newton's method.

684
00:44:51,260 --> 00:44:55,860
And the guess we start with
we'll call y0, and then we

685
00:44:55,860 --> 00:45:01,100
will iterate the following
expression.

686
00:45:01,100 --> 00:45:04,880
y n plus 1-- this is a
difference equation--

687
00:45:04,880 --> 00:45:17,366
is yn minus f of yn over the
derivative with respect to y

688
00:45:17,366 --> 00:45:23,270
of f evaluated at y equal yn.

689
00:45:23,270 --> 00:45:26,430
Very strange notation.

690
00:45:26,430 --> 00:45:31,700
I must say ugh.

691
00:45:31,700 --> 00:45:35,990
The derivative of f with respect
to y is a function.

692
00:45:35,990 --> 00:45:38,420
I'm having a little bit of
unhappiness with that, but

693
00:45:38,420 --> 00:45:39,120
that's all right.

694
00:45:39,120 --> 00:45:41,050
It turns out in the programming
language world,

695
00:45:41,050 --> 00:45:43,930
the notation is much clearer.

696
00:45:43,930 --> 00:45:45,950
Now, what is this?

697
00:45:45,950 --> 00:45:47,330
People call it Newton's
method.

698
00:45:47,330 --> 00:45:54,250
It's a method for finding the
roots of the function f.

699
00:45:54,250 --> 00:45:56,410
And it, of course, sometimes
converges, and when it does,

700
00:45:56,410 --> 00:45:59,310
it does so very fast. And
sometimes, it doesn't

701
00:45:59,310 --> 00:46:03,230
converge, and, oh well, we have
to do something else.

702
00:46:03,230 --> 00:46:07,190
But let's talk about square
root by Newton's method.

703
00:46:07,190 --> 00:46:08,680
Well, that's rather
interesting.

704
00:46:08,680 --> 00:46:11,340
Let's do exactly the same thing
we did last time: a bit

705
00:46:11,340 --> 00:46:13,490
of wishful thinking.

706
00:46:13,490 --> 00:46:18,210
We will apply Newton's method,
assuming we knew how to do it.

707
00:46:18,210 --> 00:46:20,620
You don't know how
to do it yet.

708
00:46:20,620 --> 00:46:21,870
Well, let's go.

709
00:46:25,090 --> 00:46:26,070
What do I have here?

710
00:46:26,070 --> 00:46:27,320
The square root of x.

711
00:46:31,410 --> 00:46:37,480
It's Newton's method applied
to a procedure which will

712
00:46:37,480 --> 00:46:39,990
represent that function
of y, which computes

713
00:46:39,990 --> 00:46:42,480
that function of y.

714
00:46:42,480 --> 00:46:48,820
Well, that procedure is that
procedure of y, which is the

715
00:46:48,820 --> 00:46:51,810
difference between x and
the square of y.

716
00:47:00,080 --> 00:47:07,570
Indeed, if I had a value of y
for which this was zero, then

717
00:47:07,570 --> 00:47:10,020
y would be the square
root of x.

718
00:47:13,730 --> 00:47:15,550
See that?

719
00:47:15,550 --> 00:47:19,250
OK, I'm going to start this
out searching at 1.

720
00:47:19,250 --> 00:47:23,570
Again, completely arbitrary
property of square roots that

721
00:47:23,570 --> 00:47:24,820
I can do that.

722
00:47:27,950 --> 00:47:31,480
Now, how am I going to compute
Newton's method?

723
00:47:31,480 --> 00:47:32,170
Well, this is the method.

724
00:47:32,170 --> 00:47:34,310
I have it right here.

725
00:47:34,310 --> 00:47:37,740
In fact, what I'm doing is
looking for a fixed point of

726
00:47:37,740 --> 00:47:41,240
some procedure.

727
00:47:41,240 --> 00:47:45,190
This procedure involves some
complicated expressions in

728
00:47:45,190 --> 00:47:47,150
terms of other complicated
things.

729
00:47:47,150 --> 00:47:48,800
Well, I'm trying to find the
fixed point of this.

730
00:47:48,800 --> 00:47:54,620
I want to find the values of y,
which if I put y in here, I

731
00:47:54,620 --> 00:48:00,130
get the same value out here up
to some degree of accuracy.

732
00:48:00,130 --> 00:48:02,710
Well, I already have a
fixed point process

733
00:48:02,710 --> 00:48:05,040
around to do that.

734
00:48:05,040 --> 00:48:07,350
And so, let's just define
Newton's method over here.

735
00:48:19,430 --> 00:48:21,680
A procedure which computes
a function and a

736
00:48:21,680 --> 00:48:26,640
guess, initial guess.

737
00:48:26,640 --> 00:48:28,920
Now, I'm going to have
to do something here.

738
00:48:28,920 --> 00:48:33,280
I'm going to need the derivative
of the function.

739
00:48:33,280 --> 00:48:36,550
I'm going to need a procedure
which computes the derivative

740
00:48:36,550 --> 00:48:39,490
of the function computed by
the given a procedure f.

741
00:48:42,140 --> 00:48:44,440
I'm trying to be very careful
about what I'm saying.

742
00:48:44,440 --> 00:48:46,270
I don't want to mix up the word
procedure and function.

743
00:48:46,270 --> 00:48:47,875
Function is a mathematical
word.

744
00:48:47,875 --> 00:48:52,950
It says I'm mapping from values
to other values, a set

745
00:48:52,950 --> 00:48:55,430
of ordered pairs.

746
00:48:55,430 --> 00:49:00,380
But sometimes, I'll accidentally
mix those up.

747
00:49:00,380 --> 00:49:01,655
Procedures compute functions.

748
00:49:07,400 --> 00:49:12,100
So I'm going to define the
derivative of f to be by

749
00:49:12,100 --> 00:49:12,930
wishful thinking again.

750
00:49:12,930 --> 00:49:14,720
I don't know how I'm
going to do it.

751
00:49:14,720 --> 00:49:15,970
Let's worry about that later--

752
00:49:18,612 --> 00:49:25,340
of F. So if F is a procedure,
which happens to be this one

753
00:49:25,340 --> 00:49:31,800
over here for a square root,
then DF will be the derivative

754
00:49:31,800 --> 00:49:34,890
of it, which is also the
derivative of the function

755
00:49:34,890 --> 00:49:36,080
computed by that procedure.

756
00:49:36,080 --> 00:49:38,760
DF will be a procedure that
computes the derivative of the

757
00:49:38,760 --> 00:49:42,920
function computed by the
procedure F. And then given

758
00:49:42,920 --> 00:49:44,850
that, I will just go looking
for a fixed point.

759
00:49:51,910 --> 00:49:53,710
What is the fixed point
I'm looking for?

760
00:49:53,710 --> 00:49:57,580
It's the one for that procedure
of one argument x,

761
00:49:57,580 --> 00:50:00,500
which I compute by
subtracting x.

762
00:50:00,500 --> 00:50:04,870
That's the old-- that's
the yn here.

763
00:50:04,870 --> 00:50:21,110
The quotient of f of x and df
of x, starting out with the

764
00:50:21,110 --> 00:50:22,360
original guess.

765
00:50:29,450 --> 00:50:32,640
That's all very simple.

766
00:50:32,640 --> 00:50:35,130
Now, I have one part left that
I haven't written, and I want

767
00:50:35,130 --> 00:50:37,720
you to see the process by which
I write these things,

768
00:50:37,720 --> 00:50:40,150
because this is really true.

769
00:50:40,150 --> 00:50:43,810
I start out with some
mathematical idea, perhaps.

770
00:50:43,810 --> 00:50:48,440
By wishful thinking, I assume
that by some magic I can do

771
00:50:48,440 --> 00:50:50,980
something that I have
a name for.

772
00:50:50,980 --> 00:50:54,850
I'm not going to worry about
how I do it yet.

773
00:50:54,850 --> 00:50:57,970
Then I go walking down here and
say, well, by some magic,

774
00:50:57,970 --> 00:51:01,142
I'm somehow going to figure how
to do that, but I'm going

775
00:51:01,142 --> 00:51:04,330
to write my program anyway.

776
00:51:04,330 --> 00:51:07,990
Wishful thinking, essential
to good engineering, and

777
00:51:07,990 --> 00:51:10,060
certainly essential to a
good computer science.

778
00:51:12,770 --> 00:51:15,900
So anyway, how many of
you wished that your

779
00:51:15,900 --> 00:51:17,150
computer ran faster?

780
00:51:21,120 --> 00:51:23,390
Well, the derivative isn't
so bad either.

781
00:51:23,390 --> 00:51:24,640
Sort of like average damping.

782
00:51:28,922 --> 00:51:34,010
The derivative is a procedure
that takes a procedure that

783
00:51:34,010 --> 00:51:38,560
computes a function as its
argument, and it produces a

784
00:51:38,560 --> 00:51:42,230
procedure that computes a
function, which needs one

785
00:51:42,230 --> 00:51:43,930
argument x.

786
00:51:43,930 --> 00:51:46,270
Well, you all know
this definition.

787
00:51:46,270 --> 00:51:49,040
It's f of x plus delta x minus
f of x over delta x, right?

788
00:51:49,040 --> 00:51:50,800
For some small delta x.

789
00:51:50,800 --> 00:51:59,850
So that's the quotient of the
difference of f of the sum of

790
00:51:59,850 --> 00:52:10,345
x and dx minus f point
x divided by dx.

791
00:52:18,530 --> 00:52:21,360
I think the thing was lining up
correctly when I balanced

792
00:52:21,360 --> 00:52:22,610
the parentheses.

793
00:52:25,120 --> 00:52:27,070
Now, I want you to
look at this.

794
00:52:27,070 --> 00:52:28,320
Just look.

795
00:52:31,330 --> 00:52:33,220
I suppose I haven't told
you what dx is.

796
00:52:33,220 --> 00:52:44,880
Somewhere in the world I'm going
to have to write down

797
00:52:44,880 --> 00:52:45,770
something like that.

798
00:52:45,770 --> 00:52:48,150
I'm not interested.

799
00:52:48,150 --> 00:52:52,970
This is a procedure which takes
a procedure and produces

800
00:52:52,970 --> 00:52:55,950
an approximation, a procedure
that computes an approximation

801
00:52:55,950 --> 00:52:58,010
of the derivative of the
function computed by the

802
00:52:58,010 --> 00:53:02,740
procedure given by the standard
methods that you all

803
00:53:02,740 --> 00:53:04,800
know and love.

804
00:53:04,800 --> 00:53:08,920
Now, it may not be the case that
doing this operation is

805
00:53:08,920 --> 00:53:11,390
such a good way of approximating
a derivative.

806
00:53:11,390 --> 00:53:14,800
Numerical analysts here
should jump on me and

807
00:53:14,800 --> 00:53:16,690
say don't do that.

808
00:53:16,690 --> 00:53:20,150
Computing derivatives produces
noisy answers, which is true.

809
00:53:20,150 --> 00:53:24,850
However, this again is for the
sake of understanding.

810
00:53:24,850 --> 00:53:26,620
Look what we've got.

811
00:53:26,620 --> 00:53:29,040
We started out with what is
apparently a mathematically

812
00:53:29,040 --> 00:53:31,210
complex thing.

813
00:53:31,210 --> 00:53:31,610
and.

814
00:53:31,610 --> 00:53:35,370
In a few blackboards full, we
managed to decompose the

815
00:53:35,370 --> 00:53:37,900
problem of computing square
roots by the way you were

816
00:53:37,900 --> 00:53:41,770
taught in your college
calculus class--

817
00:53:41,770 --> 00:53:43,720
Newton's method--

818
00:53:43,720 --> 00:53:45,830
so that it can be understood.

819
00:53:45,830 --> 00:53:47,840
It's clear.

820
00:53:47,840 --> 00:53:51,231
Let's look at the structure
of what it is we've got.

821
00:53:51,231 --> 00:53:54,660
Let's look at this slide.

822
00:53:54,660 --> 00:54:03,110
This is a diagram of the machine
described by the

823
00:54:03,110 --> 00:54:05,520
program on the blackboard.

824
00:54:05,520 --> 00:54:08,940
There's a machine
described here.

825
00:54:08,940 --> 00:54:10,700
And what have I got?

826
00:54:10,700 --> 00:54:17,690
Over here is the Newton's method
function f that we have

827
00:54:17,690 --> 00:54:21,040
on the left-most blackboard.

828
00:54:21,040 --> 00:54:24,990
It's the thing that takes an
argument called y and puts out

829
00:54:24,990 --> 00:54:32,500
the difference between x and
the square of y, where x is

830
00:54:32,500 --> 00:54:35,400
some sort of free variable that
comes in from the outside

831
00:54:35,400 --> 00:54:38,050
by some magic.

832
00:54:38,050 --> 00:54:43,430
So the square root routine picks
up an x, and builds this

833
00:54:43,430 --> 00:54:47,750
procedure, which I have the
x rolled up in it by

834
00:54:47,750 --> 00:54:50,170
substitution.

835
00:54:50,170 --> 00:54:58,930
Now, this procedure in the cloud
is fed in as the f into

836
00:54:58,930 --> 00:55:01,630
the Newton's method which
is here, this box.

837
00:55:04,650 --> 00:55:08,790
The f is fanned out.

838
00:55:08,790 --> 00:55:12,130
Part of it goes into something
else, and the other part of it

839
00:55:12,130 --> 00:55:15,670
goes through a derivative
process into something else to

840
00:55:15,670 --> 00:55:20,570
produce a procedure, which
computes the function which is

841
00:55:20,570 --> 00:55:24,090
the iteration function of
Newton's method when we use

842
00:55:24,090 --> 00:55:27,450
the fixed point method.

843
00:55:27,450 --> 00:55:33,030
So this procedure, which
contains it by substitution--

844
00:55:33,030 --> 00:55:37,730
remember, Newton's method over
here, Newton's method builds

845
00:55:37,730 --> 00:55:43,010
this procedure, and Newton's
method has in it defined f and

846
00:55:43,010 --> 00:55:48,900
df, so those are captured
over here: f and df.

847
00:55:48,900 --> 00:55:51,930
Starting with this procedure,
I can now feed this to the

848
00:55:51,930 --> 00:55:55,260
fixed point process within an
initial guess coming out from

849
00:55:55,260 --> 00:55:59,135
the outside from square
root to produce the

850
00:55:59,135 --> 00:56:00,385
square root of x.

851
00:56:03,680 --> 00:56:07,680
So what we've built is a very
powerful engine, which allows

852
00:56:07,680 --> 00:56:11,256
us to make nice things
like this.

853
00:56:11,256 --> 00:56:19,000
Now, I want to end this with
basically an idea of Chris

854
00:56:19,000 --> 00:56:21,520
Strachey, one of the

855
00:56:21,520 --> 00:56:23,230
grandfathers of computer science.

856
00:56:23,230 --> 00:56:27,440
He's a logician who
lived in the--

857
00:56:27,440 --> 00:56:30,320
I suppose about 10 years ago
or 15 years ago, he died.

858
00:56:30,320 --> 00:56:31,840
I don't remember exactly when.

859
00:56:31,840 --> 00:56:33,250
He's one of the inventors
of something called

860
00:56:33,250 --> 00:56:34,820
denotational semantics.

861
00:56:34,820 --> 00:56:40,560
He was a great advocate of
making procedures or functions

862
00:56:40,560 --> 00:56:43,950
first-class citizens in a
programming language.

863
00:56:43,950 --> 00:56:46,910
So here's the rights and
privileges of first-class

864
00:56:46,910 --> 00:56:50,690
citizens in a programming
language.

865
00:56:50,690 --> 00:56:53,070
It allows you to make any
abstraction you like if you

866
00:56:53,070 --> 00:56:57,710
have functions as first-class
citizens.

867
00:56:57,710 --> 00:56:59,030
The first-class citizens
must be able

868
00:56:59,030 --> 00:57:02,270
to be named by variables.

869
00:57:02,270 --> 00:57:04,600
And you're seeing me doing
that all the time.

870
00:57:04,600 --> 00:57:07,700
Here's a nice variable which
names a procedure which

871
00:57:07,700 --> 00:57:08,950
computes something.

872
00:57:13,270 --> 00:57:15,370
They have to be passed as
arguments to procedures.

873
00:57:15,370 --> 00:57:18,540
We've certainly seen that.

874
00:57:18,540 --> 00:57:20,640
We have to be able to return
them as values from

875
00:57:20,640 --> 00:57:23,340
procedures.

876
00:57:23,340 --> 00:57:25,300
And I suppose we've seen that.

877
00:57:25,300 --> 00:57:27,970
We haven't yet seen anything
about data structures.

878
00:57:27,970 --> 00:57:31,490
We will soon, but it's also the
case that in order to have

879
00:57:31,490 --> 00:57:33,940
a first-class citizen in a
programming language, the

880
00:57:33,940 --> 00:57:37,200
object has to be allowed to be
part of a data structure.

881
00:57:37,200 --> 00:57:39,110
We're going to see that soon.

882
00:57:39,110 --> 00:57:43,530
So I just want to close with
this and say having things

883
00:57:43,530 --> 00:57:46,180
like procedures as first-class
data structures, first-class

884
00:57:46,180 --> 00:57:50,780
data, allows one to make
powerful abstractions, which

885
00:57:50,780 --> 00:57:53,110
encode general methods
like Newton's method

886
00:57:53,110 --> 00:57:54,780
in very clear way.

887
00:57:54,780 --> 00:57:57,430
Are there any questions?

888
00:57:57,430 --> 00:57:57,780
Yes.

889
00:57:57,780 --> 00:58:00,040
AUDIENCE: Could you put
derivative instead of df

890
00:58:00,040 --> 00:58:02,570
directly in the fixed point?

891
00:58:02,570 --> 00:58:03,810
PROFESSOR: Oh, sure.

892
00:58:03,810 --> 00:58:09,220
Yes, I could have put deriv of
f right here, no question.

893
00:58:11,810 --> 00:58:16,190
Any time you see something
defined, you can put the thing

894
00:58:16,190 --> 00:58:18,950
that the definition is
there because you

895
00:58:18,950 --> 00:58:21,060
get the same result.

896
00:58:21,060 --> 00:58:22,800
In fact, what that would look
like, it's interesting.

897
00:58:22,800 --> 00:58:23,750
AUDIENCE: Lambda.

898
00:58:23,750 --> 00:58:24,085
PROFESSOR: Huh?

899
00:58:24,085 --> 00:58:25,970
AUDIENCE: You could put the
lambda expression in there.

900
00:58:25,970 --> 00:58:29,990
PROFESSOR: I could also put
derivative of f here.

901
00:58:29,990 --> 00:58:32,640
It would look interesting
because of the open paren,

902
00:58:32,640 --> 00:58:38,610
open paren, deriv of f,
closed paren on an x.

903
00:58:38,610 --> 00:58:40,900
Now, that would have the bad
property of computing the

904
00:58:40,900 --> 00:58:43,980
derivative many times, because
every time I would run this

905
00:58:43,980 --> 00:58:45,490
procedure, I would compute
the derivative again.

906
00:58:48,030 --> 00:58:52,510
However, the two open parens
here both would be meaningful.

907
00:58:52,510 --> 00:58:54,600
I want you to understand
syntactically that that's a

908
00:58:54,600 --> 00:58:55,350
sensible thing.

909
00:58:55,350 --> 00:58:58,190
Because if was to rewrite this
program-- and I should do it

910
00:58:58,190 --> 00:59:00,210
right here just so
you see because

911
00:59:00,210 --> 00:59:01,460
that's a good question--

912
00:59:11,490 --> 00:59:25,430
of F and guess to be fixed point
of that procedure of one

913
00:59:25,430 --> 00:59:34,920
argument x, which subtracts
from x the quotient of F

914
00:59:34,920 --> 00:59:45,045
applied to x and the deriv
of F applied to x.

915
00:59:53,459 --> 00:59:54,709
This is guess.

916
00:59:59,960 --> 01:00:02,680
This is a perfectly legitimate
program,

917
01:00:02,680 --> 01:00:04,250
because what I have here--

918
01:00:04,250 --> 01:00:05,910
remember the evaluation rule.

919
01:00:05,910 --> 01:00:08,760
The evaluation rule is evaluate
all of the parts of

920
01:00:08,760 --> 01:00:12,070
the combination: the operator
and the operands.

921
01:00:12,070 --> 01:00:14,575
This is the operator of
this combination.

922
01:00:17,080 --> 01:00:21,080
Evaluating this operator will,
of course, produce the

923
01:00:21,080 --> 01:00:28,250
derivative of F.

924
01:00:28,250 --> 01:00:30,300
AUDIENCE: To get it one step
further, you could put the

925
01:00:30,300 --> 01:00:31,200
lambda expression there, too.

926
01:00:31,200 --> 01:00:33,180
PROFESSOR: Oh, of course.

927
01:00:33,180 --> 01:00:37,620
Any time I take something which
is define, I can put the

928
01:00:37,620 --> 01:00:40,420
thing it's defined to be in
the place where the thing

929
01:00:40,420 --> 01:00:42,420
defined is.

930
01:00:42,420 --> 01:00:44,430
I can't remember which is
definiens and which is

931
01:00:44,430 --> 01:00:45,680
definiendum.

932
01:00:47,490 --> 01:00:50,230
When I'm trying to figure out
how to do a lecture about this

933
01:00:50,230 --> 01:00:54,160
in a freshman class, I use such
words and tell everybody

934
01:00:54,160 --> 01:00:55,440
it's fun to tell
their friends.

935
01:00:59,470 --> 01:01:01,460
OK, I think that's it.